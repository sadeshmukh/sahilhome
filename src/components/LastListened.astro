<div id="last-listened" hidden>
  <div class="compact-view">
    <span class="listening-text">Listening to</span>
    <span id="last-listened-song" class="last-listened-inner"></span>
    <span class="artist-section">
      by
      <span id="last-listened-artist" class="last-listened-inner"></span>
    </span>
    <span class="time-ago"></span>
  </div>
  <div class="expanded-view">
    <div class="album-art">
      <img id="album-image" src="/favicon.ico" alt="Album Art" />
    </div>
    <div class="track-info">
      <div class="song-name"></div>
      <div class="metadata">
        <span class="artist-album-section">
          <span class="artist"></span>
          <span class="dot">•</span>
          <span class="album"></span>
        </span>
        <span class="expanded-time-ago"></span>
      </div>
    </div>
  </div>
</div>

<style>
  #last-listened {
    position: absolute;
    top: 13rem;
    left: 50%;
    transform: translateX(-50%);
    z-index: 2;
    color: rgba(0, 255, 153, 0.7);
    font-family: "Chakra Petch", monospace;
    background: rgba(0, 255, 153, 0.05);
    border: 1px solid rgba(0, 255, 153, 0.1);
    border-radius: 12px;
    padding: 0.5rem 1rem;
    backdrop-filter: blur(10px);
    transition: all 0.3s ease;
  }

  #last-listened:hover {
    transform: translateX(-50%) scale(1.05);
    background: rgba(0, 255, 153, 0.1);
    border-color: rgba(0, 255, 153, 0.2);
  }

  .last-listened-inner {
    font-weight: bold;
  }

  .expanded-view {
    display: none;
    grid-template-columns: 60px 1fr;
    gap: 1rem;
    padding: 0.5rem;
  }

  #last-listened:hover .compact-view {
    display: none;
  }

  #last-listened:hover .expanded-view {
    display: grid;
  }

  .album-art {
    width: 60px;
    height: 60px;
    border-radius: 6px;
    overflow: hidden;
  }

  .album-art img {
    width: 100%;
    height: 100%;
    object-fit: cover;
  }

  .track-info {
    display: flex;
    flex-direction: column;
    justify-content: center;
    min-width: 0;
  }

  .song-name {
    font-size: 1.1rem;
    font-weight: bold;
    color: #00ff99;
    margin-bottom: 0.25rem;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .metadata {
    font-size: 0.9rem;
    color: rgba(0, 255, 153, 0.7);
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }

  .dot {
    margin: 0 0.5rem;
  }

  .time-ago,
  .expanded-time-ago {
    color: rgba(0, 255, 153, 0.5);
    font-size: 0.85em;
    margin-left: 0.5rem;
  }

  .expanded-time-ago {
    margin-left: 1rem;
  }

  @media (max-width: 768px) {
    #last-listened {
      width: calc(100% - 2rem);
      text-align: center;
      font-size: 0.9rem;
      padding: 0.75rem 1rem;
      top: 11rem;
    }

    #last-listened:hover {
      transform: none;
      width: calc(100% - 2rem);
    }

    .expanded-view {
      grid-template-columns: 50px 1fr;
    }

    .album-art {
      width: 50px;
      height: 50px;
    }

    .song-name {
      font-size: 1rem;
    }

    .metadata {
      font-size: 0.8rem;
    }
  }
</style>

<script>
  interface TrackResponse {
    artist: string;
    track: string;
    album: string;
    url: string;
    image: string;
    now_playing: boolean;
    when: string;
    release_date: string | null;
  }

  function formatTimeAgo(timestamp: string): string {
    const now = Math.floor(Date.now() / 1000);
    const then = parseInt(timestamp);
    const diff = now - then;

    if (diff < 60) return "just now";
    if (diff < 3600) return `${Math.floor(diff / 60)}m ago`;
    if (diff < 86400) return `${Math.floor(diff / 3600)}h ago`;
    if (diff < 2592000) return `${Math.floor(diff / 86400)}d ago`;
    return `${Math.floor(diff / 2592000)}mo ago`;
  }

  async function getLastListened() {
    try {
      const url = import.meta.env.PUBLIC_LAST_LISTENED_URL;
      const response = await fetch(url);
      const data = await response.json();

      // If fields aren't there, then API is out of date - just forget it, log, and skip
      if (
        !data ||
        typeof data !== "object" ||
        !("artist" in data) ||
        !("track" in data) ||
        !("now_playing" in data) ||
        !("image" in data)
      ) {
        console.error("Invalid API response schema:", data);
        throw new Error("Invalid API response schema");
      }

      const elements = {
        artist: document.querySelector(
          "#last-listened-artist",
        ) as HTMLElement | null,
        song: document.querySelector(
          "#last-listened-song",
        ) as HTMLElement | null,
        albumArt: document.querySelector(
          "#album-image",
        ) as HTMLImageElement | null,
        expandedSong: document.querySelector(
          ".song-name",
        ) as HTMLElement | null,
        expandedArtist: document.querySelector(".artist") as HTMLElement | null,
        expandedAlbum: document.querySelector(".album") as HTMLElement | null,
        container: document.querySelector(
          "#last-listened",
        ) as HTMLDivElement | null,
        listeningText: document.querySelector(
          ".listening-text",
        ) as HTMLElement | null,
        timeAgo: document.querySelector(".time-ago") as HTMLElement | null,
        expandedTimeAgo: document.querySelector(
          ".expanded-time-ago",
        ) as HTMLElement | null,
      };

      if (elements.container) {
        elements.container.hidden = false;

        if (elements.listeningText) {
          elements.listeningText.textContent = data.now_playing
            ? "Listening to"
            : "Last listened to";
        }

        if (elements.song) elements.song.textContent = data.track;
        if (elements.expandedSong)
          elements.expandedSong.textContent = data.track;

        // artist/album visibility
        const artistSection = document.querySelector(
          ".artist-section",
        ) as HTMLElement;
        const artistAlbumSection = document.querySelector(
          ".artist-album-section",
        ) as HTMLElement;

        if (data.artist && data.artist.trim()) {
          if (artistSection) artistSection.style.display = "inline";
          if (artistAlbumSection) artistAlbumSection.style.display = "inline";

          if (elements.artist) elements.artist.textContent = data.artist;
          if (elements.expandedArtist)
            elements.expandedArtist.textContent = data.artist;
          if (elements.expandedAlbum)
            elements.expandedAlbum.textContent = data.album || "Unknown Album";
        } else {
          if (artistSection) artistSection.style.display = "none";
          if (artistAlbumSection) artistAlbumSection.style.display = "none";
        }

        // *non-current* tracks
        if (!data.now_playing && data.when) {
          const timeAgoText = formatTimeAgo(data.when);
          if (elements.timeAgo)
            elements.timeAgo.textContent = ` • ${timeAgoText}`;
          if (elements.expandedTimeAgo)
            elements.expandedTimeAgo.textContent = ` • ${timeAgoText}`;
        } else {
          if (elements.timeAgo) elements.timeAgo.textContent = "";
          if (elements.expandedTimeAgo)
            elements.expandedTimeAgo.textContent = "";
        }

        // fallback to favicon
        if (elements.albumArt) {
          elements.albumArt.src = data.image || "/favicon.ico";
          elements.albumArt.onerror = () => {
            if (elements.albumArt) elements.albumArt.src = "/favicon.ico";
          };
        }
      } else if (elements.container) {
        (elements.container as HTMLElement).hidden = true;
      }
    } catch (error) {
      console.error("Failed to fetch or process last listened track:", error);
      const container = document.querySelector("#last-listened") as HTMLElement;
      if (container) container.hidden = true;
    }
  }

  setTimeout(getLastListened, 1000);
  setInterval(getLastListened, 1000 * 60); // TODO: smaller interval, update listen.sahil.ink caching
</script>
